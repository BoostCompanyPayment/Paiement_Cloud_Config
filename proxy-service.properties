# Port du serveur
server.port=8079

# Configuration d'Eureka
eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
#eureka.client.service-url.defaultZone=http://registry-service:8761/eureka/
#eureka.client.service-url.defaultZone=http://aee728fb4434b4726849e1369381ed5e-655874721.us-east-1.elb.amazonaws.com:8761/eureka/

eureka.client.fetch-registry=true

# Activer la d√©couverte automatique des services pour le Gateway
spring.cloud.gateway.discovery.locator.enabled=true
spring.cloud.gateway.discovery.locator.lower-case-service-id=true

# Configuration des routes manuelles
#spring.cloud.gateway.routes[0].id=authface-service
#spring.cloud.gateway.routes[0].uri=lb://authface-service
#spring.cloud.gateway.routes[0].predicates[0]=Path=/AUTHFACE-SERVICE/**
#spring.cloud.gateway.routes[0].filters[0]=StripPrefix=1

# --- Explicit routes for payment-service (both casings) to aid local testing ---
# These map /PAYMENT-SERVICE/** and /payment-service/** directly to the payment service
# and strip the first path segment so the downstream service receives /api/...
spring.cloud.gateway.routes[0].id=payment-service-explicit-upper
spring.cloud.gateway.routes[0].uri=lb://payment-service
spring.cloud.gateway.routes[0].predicates[0]=Path=/PAYMENT-SERVICE/**
spring.cloud.gateway.routes[0].filters[0]=StripPrefix=1

spring.cloud.gateway.routes[1].id=payment-service-explicit-lower
spring.cloud.gateway.routes[1].uri=lb://payment-service
spring.cloud.gateway.routes[1].predicates[0]=Path=/payment-service/**
spring.cloud.gateway.routes[1].filters[0]=StripPrefix=1

# Explicit routes for merchent-service (both casings) to aid local testing
spring.cloud.gateway.routes[2].id=merchent-service-explicit-upper
spring.cloud.gateway.routes[2].uri=lb://merchent-service
spring.cloud.gateway.routes[2].predicates[0]=Path=/MERCHENT-SERVICE/**
spring.cloud.gateway.routes[2].filters[0]=StripPrefix=1

spring.cloud.gateway.routes[3].id=merchent-service-explicit-lower
spring.cloud.gateway.routes[3].uri=lb://merchent-service
spring.cloud.gateway.routes[3].predicates[0]=Path=/merchent-service/**
spring.cloud.gateway.routes[3].filters[0]=StripPrefix=1



# Configuration des m√©triques et sant√©
management.endpoint.health.show-details=always
management.endpoints.web.exposure.include=metrics,health,gateway,loadbalancer
management.health.circuitbreakers.enabled=true
management.endpoint.gateway.enabled=true

# Configuration du load balancer personnalis√©
custom.lb.strategy=pred-entropy
spring.cloud.loadbalancer.ribbon.enabled=false

# üöÄ CONFIGURATION LOAD BALANCER PR√âDICTIF-ENTROPIQUE
# ====================================================

# Type de load balancer (optimized|basic)
loadbalancer.type=basic
loadbalancer.entropy-threshold=0.75
loadbalancer.health-check-interval=3
loadbalancer.failure-threshold=3
loadbalancer.enable-metrics=true

# Configuration avanc√©e du Load Balancer
spring.cloud.loadbalancer.enabled=true
spring.cloud.loadbalancer.retry.enabled=true
spring.cloud.loadbalancer.retry.max-retries-on-same-service-instance=1
spring.cloud.loadbalancer.retry.max-retries-on-next-service-instance=2
spring.cloud.loadbalancer.retry.retryable-status-codes=500,502,503,504

# Cache et performance
spring.cloud.loadbalancer.cache.enabled=true
spring.cloud.loadbalancer.cache.ttl=35s
spring.cloud.loadbalancer.cache.capacity=256

# Health checks optimis√©s
spring.cloud.loadbalancer.health-check.initial-delay=1s
spring.cloud.loadbalancer.health-check.interval=5s
spring.cloud.loadbalancer.health-check.path.default=/actuator/health

# Circuit Breaker int√©gr√©
resilience4j.circuitbreaker.enabled=true
resilience4j.circuitbreaker.instances.default.failure-rate-threshold=50
resilience4j.circuitbreaker.instances.default.slow-call-rate-threshold=50
resilience4j.circuitbreaker.instances.default.slow-call-duration-threshold=2s
resilience4j.circuitbreaker.instances.default.minimum-number-of-calls=10
resilience4j.circuitbreaker.instances.default.sliding-window-size=20
resilience4j.circuitbreaker.instances.default.wait-duration-in-open-state=30s

# üéØ CONFIGURATION SP√âCIFIQUE ENTROPIE ADAPTATIVE
# ==============================================

# Param√®tres d'entropie
loadbalancer.entropy.adaptive-threshold=0.75
loadbalancer.entropy.variance-weight=0.3
loadbalancer.entropy.max-variance-influence=0.3

# Param√®tres de pr√©diction
loadbalancer.prediction.history-size=20
loadbalancer.prediction.trend-weight=0.3
loadbalancer.prediction.accuracy-threshold=0.85

# Scoring des instances
loadbalancer.scoring.load-weight=0.4
loadbalancer.scoring.stability-weight=0.2
loadbalancer.scoring.latency-weight=0.15
loadbalancer.scoring.entropy-weight=0.1
loadbalancer.scoring.affinity-weight=0.1
loadbalancer.scoring.clustering-weight=0.05

# Auto-tuning et apprentissage
loadbalancer.learning.min-requests=100
loadbalancer.learning.accuracy-high-threshold=0.9
loadbalancer.learning.accuracy-low-threshold=0.7
loadbalancer.learning.threshold-adjustment=0.01

# üìä MONITORING ET M√âTRIQUES
# ==========================

# Actuator endpoints pour monitoring
management.endpoints.web.base-path=/actuator
management.endpoint.metrics.enabled=true
management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true

# M√©triques personnalis√©es
management.metrics.enable.loadbalancer=true
management.metrics.enable.gateway=true
management.metrics.enable.jvm=true
management.metrics.enable.system=true

# Tags pour m√©triques
management.metrics.tags.application=proxy_service
management.metrics.tags.version=1.0.0
management.metrics.tags.environment=development

# üîß OPTIMISATIONS PERFORMANCE
# ============================

# Pool de connexions
spring.cloud.gateway.httpclient.pool.type=elastic
spring.cloud.gateway.httpclient.pool.max-connections=5000
spring.cloud.gateway.httpclient.pool.max-idle-time=30s
spring.cloud.gateway.httpclient.pool.max-life-time=60s

# Timeouts
spring.cloud.gateway.httpclient.connect-timeout=3000
spring.cloud.gateway.httpclient.response-timeout=10s

# WebClient configuration
spring.webflux.multipart.max-in-memory-size=1MB
spring.webflux.multipart.max-disk-usage-per-part=10MB

# üõ°Ô∏è S√âCURIT√â ET STABILIT√â - VERSION CORRIG√âE
# ===========================================

# CORS configuration - CORRECTION du probl√®me allowCredentials + allowedOrigins
spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-origin-patterns=*
spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-methods=GET,POST,PUT,DELETE,OPTIONS
spring.cloud.gateway.globalcors.cors-configurations.[/**].allowed-headers=*
spring.cloud.gateway.globalcors.cors-configurations.[/**].allow-credentials=true
spring.cloud.gateway.globalcors.cors-configurations.[/**].max-age=3600

# üìà LOGGING ET DEBUGGING
# =======================

# Niveaux de log
logging.level.com.election.api_gateway_aldpeb_service.loadbalancer=DEBUG
logging.level.org.springframework.cloud.loadbalancer=INFO
logging.level.org.springframework.cloud.gateway=INFO
logging.level.reactor.netty=INFO

# Pattern de log avec m√©triques
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%logger{36}] - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%logger{36}] - %msg%n

# Fichier de log
logging.file.name=logs/proxy_service.log
logging.file.max-size=100MB
logging.file.max-history=30

# üîÑ CONFIGURATION REACTIVE
# =========================

# Reactor Netty
reactor.netty.http.server.accessLogEnabled=true
reactor.netty.pool.maxConnections=500
reactor.netty.pool.maxIdleTime=30s
reactor.netty.pool.maxLifeTime=60s

# Buffer sizes
spring.codec.max-in-memory-size=1MB

# üåê CONFIGURATION R√âSEAU
# =======================

# Interface r√©seau
server.address=0.0.0.0

# Compression
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain

# HTTP/2
server.http2.enabled=true

# SSL (si n√©cessaire)
# server.ssl.enabled=false
# server.ssl.key-store=classpath:keystore.p12
# server.ssl.key-store-password=password
# server.ssl.key-store-type=PKCS12

# üéÆ CONFIGURATION D√âVELOPPEMENT
# ==============================

# Profile actif
spring.profiles.active=kubernetes

# DevTools (d√©sactiver en production)
spring.devtools.restart.enabled=false
spring.devtools.livereload.enabled=false

# Cache d√©sactiv√© en d√©veloppement
spring.cloud.gateway.discovery.locator.lower-case-service-id=true
spring.cloud.gateway.discovery.locator.predicates[0].name=Path
spring.cloud.gateway.discovery.locator.predicates[0].args.pattern="'/'+serviceId+'/**'"
spring.cloud.gateway.discovery.locator.filters[0].name=RewritePath
spring.cloud.gateway.discovery.locator.filters[0].args.regexp="'/'+serviceId+'/(?<remaining>.*)'"
spring.cloud.gateway.discovery.locator.filters[0].args.replacement="'/${remaining}'"

# üöÄ CONFIGURATION POUR KUBERNETES
# =================================

# Configuration sp√©cifique pour Eureka dans Kubernetes
eureka.instance.hostname=${HOSTNAME:${spring.application.name}}
eureka.instance.prefer-ip-address=true
eureka.instance.ip-address=${POD_IP:127.0.0.1}

# Configuration pour LoadBalancer avec 5 instances d'authface
loadbalancer.kubernetes.enabled=true
loadbalancer.kubernetes.namespace=electionvotingsystem
loadbalancer.target-service=authface-service
loadbalancer.target-instances=5

# Monitoring sp√©cifique pour cluster avec HPA
management.metrics.tags.cluster-size=5
management.metrics.tags.hpa-enabled=true
management.metrics.tags.target-cpu=60%
management.metrics.tags.target-memory=80%
spring.cloud.gateway.discovery.locator.filters[0].name=RewritePath
spring.cloud.gateway.discovery.locator.filters[0].args.regexp="'/'+serviceId+'/(?<remaining>.*)'"
spring.cloud.gateway.discovery.locator.filters[0].args.replacement="'/${remaining}'"
# Cache d√©sactiv√© en d√©veloppement
spring.cloud.gateway.discovery.locator.lower-case-service-id=true
spring.cloud.gateway.discovery.locator.predicates[0].name=Path
spring.cloud.gateway.discovery.locator.predicates[0].args.pattern="'/'+serviceId+'/**'"
spring.cloud.gateway.discovery.locator.filters[0].name=RewritePath
spring.cloud.gateway.discovery.locator.filters[0].args.regexp="'/'+serviceId+'/(?<remaining>.*)'"
spring.cloud.gateway.discovery.locator.filters[0].args.replacement="'/${remaining}'"


retry.fixed-delay-ms=5000
# ========================================
# üîç ELASTICSEARCH CONFIGURATION
# ========================================
# Elasticsearch endpoint for metrics export
elasticsearch.enabled=true
elasticsearch.endpoint=https://e14274e868034c2e9b79e8f32c580213.us-central1.gcp.cloud.es.io:443
elasticsearch.api-key=Z28xczg1b0J6clJSN2RoLUpWc3A6T3luZmMwSDZPbWhvVFM3UWJubVN0Zw==
elasticsearch.index-prefix=loadbalancer-metrics

# Buffer configuration for batch export
elasticsearch.batch-size=100
elasticsearch.flush-interval-seconds=30
elasticsearch.enabled-indices=load_metrics,failed_requests,replay_metrics

# Metrics collection from local files
metrics.collector.interval-seconds=10

# ========================================
retry.max-attempts=3